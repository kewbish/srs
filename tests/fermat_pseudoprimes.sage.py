

# This file was *autogenerated* from the file fermat_pseudoprimes.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_4 = Integer(4); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_20 = Integer(20); _sage_const_10 = Integer(10); _sage_const_1000000 = Integer(1000000); _sage_const_2000000 = Integer(2000000); _sage_const_3p = RealNumber('3.'); _sage_const_100 = Integer(100)
from multiprocessing import Pool
from sage.misc.prandom import randint
from sys import argv
from typing import Union

def fermat_primality(n: int, k: int, a: int = _sage_const_0 ) -> Union[bool, tuple[bool, int]]:
    """
    Returns True if number is probably prime.
    Returns False, Fermat witness or 0: int if number is composite.
    """
    if n == _sage_const_1  or n == _sage_const_4 :
        return False
    elif n == _sage_const_2  or n == _sage_const_3 :
        return True
    elif n % _sage_const_2  == _sage_const_0 :
        return False, _sage_const_0 
    for _ in range(k):
        if a == _sage_const_0 :
            a = randint(_sage_const_2 , n - _sage_const_2 )
        if power_mod(a, n - _sage_const_1 , n) != _sage_const_1 :
            return False, a
    return True

def pseudoprimes(from_i: int, to_i: int, base: int) -> list[int]:
    pprimes = []
    for n in range(from_i - _sage_const_1 , to_i + _sage_const_1 ):
        fermat_res = fermat_primality(n, _sage_const_20 , base)
        sage_res = is_prime(n)
        if type(fermat_res) == bool and not sage_res:
            pprimes.append(n)
    return pprimes

def gen_randints() -> list[tuple[int, bool]]:
    randints = []
    for _ in range(_sage_const_10 **_sage_const_4 ):
        rand = randint(_sage_const_1000000 , _sage_const_2000000 )
        sage_rand = is_prime(rand)
        randints.append((rand, sage_rand))
    return randints

def average_pprimes(k) -> float:
    result = _sage_const_0 
    for _ in range(_sage_const_3 ):
        pprimes = _sage_const_0 
        for n, is_prime in gen_randints():
            if len(argv) == _sage_const_1 :
                fermat_res = fermat_primality(n, k) # passing all random bases
            elif len(argv) == _sage_const_2 :
                fermat_res = fermat_primality(n, k, int(argv[_sage_const_1 ])) # passing a specific base
            elif len(argv) == _sage_const_3 :
                fermat_res_2 = fermat_primality(n, k, int(argv[_sage_const_2 ]))
            if len(argv) < _sage_const_3 :
                if type(fermat_res) == bool and not is_prime: # for passing 1 base
                    print(f"Fermat pseudoprime: {n}, tries: {k}")
                    pprimes += _sage_const_1 
            else:
                if type(fermat_res) and type(fermat_res_2) == bool and not is_prime: # for passing 2 bases together
                # Fermat primality returns True, Sage returns False => pseudoprime
                    print(f"Fermat pseudoprime: {n}, tries: {k}")
                    pprimes += _sage_const_1 
        result += pprimes
    return numerical_approx(result / _sage_const_3p , digits=_sage_const_2 )

if __name__ == "__main__":
    with Pool(_sage_const_4 ) as p:
        results = {k: average_pprimes(k) for k in range(_sage_const_1 , _sage_const_100 )}
    print(results)
    # lowest number of tries for lowest number of pseudoprimes
    print(sorted(results.items(), key=lambda x: x[_sage_const_1 ])[_sage_const_0 ])

